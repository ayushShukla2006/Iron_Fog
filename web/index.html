<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>IRON FOG</title>
<link rel="icon" href="favicon.ico" type="image/x-icon">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Oswald:wght@400;600;700&display=swap');

  :root {
    --bg:       #0a0c0f;
    --panel:    #0f1318;
    --border:   #1e2832;
    --accent:   #c8a84b;
    --red:      #e74c3c;
    --blue:     #3498db;
    --green:    #2ecc71;
    --orange:   #f39c12;
    --dim:      #3a4556;
    --text:     #c8d6e5;
    --fog:      rgba(8,12,18,0.88);
    --font-main:'Share Tech Mono', monospace;
    --font-head:'Oswald', sans-serif;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  html, body {
    width: 100%; height: 100%;
    background: var(--bg);
    color: var(--text);
    font-family: var(--font-main);
    overflow: hidden;
    user-select: none;
  }

  /* â”€â”€ LOGIN SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #login-screen {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: var(--bg);
    z-index: 100;
  }
  #login-screen h1 {
    font-family: var(--font-head);
    font-size: clamp(3rem, 8vw, 7rem);
    font-weight: 700;
    letter-spacing: 0.15em;
    color: var(--accent);
    text-shadow: 0 0 40px rgba(200,168,75,0.4), 0 0 80px rgba(200,168,75,0.15);
    margin-bottom: 0.2em;
  }
  #login-screen .subtitle {
    font-size: 0.85rem;
    letter-spacing: 0.3em;
    color: var(--dim);
    margin-bottom: 3em;
    text-transform: uppercase;
  }
  #login-screen input {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 2px;
    color: var(--text);
    font-family: var(--font-main);
    font-size: 1.1rem;
    padding: 0.7em 1.2em;
    width: 260px;
    text-align: center;
    outline: none;
    margin-bottom: 1em;
    transition: border-color 0.2s;
  }
  #login-screen input:focus { border-color: var(--accent); }
  #login-screen button {
    background: var(--accent);
    border: none; border-radius: 2px;
    color: #0a0c0f;
    font-family: var(--font-head);
    font-size: 1rem; font-weight: 600;
    letter-spacing: 0.15em;
    padding: 0.7em 2.5em;
    cursor: pointer;
    text-transform: uppercase;
    transition: background 0.15s, transform 0.1s;
  }
  #login-screen button:hover { background: #dbb85e; transform: scale(1.03); }
  #status-msg {
    margin-top: 1em; font-size: 0.8rem;
    color: var(--red); letter-spacing: 0.1em;
  }

  /* â”€â”€ GAME LAYOUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #game-wrapper {
    display: none; width: 100%; height: 100%;
    flex-direction: row;
  }
  #game-wrapper.active { display: flex; }

  /* â”€â”€ CANVAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #canvas-container {
    flex: 1; position: relative; overflow: hidden;
  }
  canvas#game-canvas {
    display: block; width: 100%; height: 100%;
    cursor: crosshair;
  }

  /* â”€â”€ RIGHT PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #side-panel {
    width: 240px;
    background: var(--panel);
    border-left: 1px solid var(--border);
    display: flex; flex-direction: column;
    padding: 0;
    overflow: hidden;
  }

  .panel-section {
    border-bottom: 1px solid var(--border);
    padding: 12px 14px;
  }

  .panel-title {
    font-family: var(--font-head);
    font-size: 0.7rem;
    letter-spacing: 0.2em;
    color: var(--dim);
    text-transform: uppercase;
    margin-bottom: 10px;
  }

  /* â”€â”€ RESOURCE BARS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .res-row {
    display: flex; align-items: center; gap: 8px;
    margin-bottom: 7px;
  }
  .res-label {
    font-size: 0.7rem;
    letter-spacing: 0.08em;
    width: 38px;
    color: var(--dim);
  }
  .res-bar-bg {
    flex: 1; height: 6px;
    background: var(--border);
    border-radius: 1px; overflow: hidden;
  }
  .res-bar-fill {
    height: 100%; border-radius: 1px;
    transition: width 0.3s ease;
  }
  .res-val {
    font-size: 0.7rem; width: 30px;
    text-align: right; color: var(--text);
  }
  .fuel-bar  { background: #27ae60; }
  .ammo-bar  { background: #c0392b; }
  .gear-bar  { background: var(--accent); }
  .hp-bar    { background: #16a085; }

  /* â”€â”€ MINIMAP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #minimap-canvas {
    width: 210px; height: 210px;
    border: 1px solid var(--border);
    border-radius: 2px;
  }

  /* â”€â”€ LEADERBOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .lb-row {
    display: flex; align-items: center;
    gap: 8px; margin-bottom: 5px;
    font-size: 0.72rem;
  }
  .lb-color {
    width: 8px; height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  .lb-name { flex: 1; color: var(--text); overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
  .lb-score { color: var(--accent); font-weight: bold; }
  .lb-forts { color: var(--dim); font-size: 0.66rem; }

  /* â”€â”€ UPGRADES PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #upgrade-panel {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0.9);
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 20px;
    width: 340px;
    z-index: 50;
    opacity: 0; pointer-events: none;
    transition: opacity 0.2s, transform 0.2s;
  }
  #upgrade-panel.open {
    opacity: 1; pointer-events: all;
    transform: translate(-50%, -50%) scale(1);
  }
  #upgrade-panel h2 {
    font-family: var(--font-head);
    font-size: 1rem; letter-spacing: 0.2em;
    color: var(--accent); margin-bottom: 15px;
    text-transform: uppercase;
  }
  .upg-item {
    display: flex; align-items: center;
    border: 1px solid var(--border);
    border-radius: 2px; padding: 9px 12px;
    margin-bottom: 8px; cursor: pointer;
    transition: border-color 0.15s, background 0.15s;
  }
  .upg-item:hover { border-color: var(--accent); background: rgba(200,168,75,0.06); }
  .upg-name {
    font-family: var(--font-head); font-size: 0.9rem;
    color: var(--text); flex: 1;
  }
  .upg-level { color: var(--dim); font-size: 0.7rem; margin-right: 10px; }
  .upg-cost { color: var(--accent); font-size: 0.75rem; }
  .upg-close {
    margin-top: 12px; width: 100%;
    background: none; border: 1px solid var(--border);
    color: var(--dim); font-family: var(--font-main);
    font-size: 0.8rem; padding: 6px; cursor: pointer;
    letter-spacing: 0.1em; transition: border-color 0.15s;
  }
  .upg-close:hover { border-color: var(--text); color: var(--text); }

  /* â”€â”€ HUD OVERLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #hud-top {
    position: absolute; top: 14px; left: 14px;
    pointer-events: none;
  }
  #tank-status {
    font-size: 0.7rem; letter-spacing: 0.1em;
    color: var(--dim);
  }
  #mode-indicator {
    position: absolute; bottom: 16px; left: 50%;
    transform: translateX(-50%);
    background: rgba(10,12,15,0.85);
    border: 1px solid var(--border);
    border-radius: 2px; padding: 5px 16px;
    font-size: 0.72rem; letter-spacing: 0.15em;
    color: var(--dim); pointer-events: none;
    text-transform: uppercase;
  }
  #mode-indicator.move-mode { color: var(--green); border-color: var(--green); }
  #mode-indicator.attack-mode { color: var(--red); border-color: var(--red); }

  /* â”€â”€ KEYBOARD HINT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #keyhints {
    position: absolute; bottom: 16px; right: 14px;
    pointer-events: none;
    text-align: right;
  }
  .keyhint { font-size: 0.65rem; letter-spacing: 0.08em; color: var(--dim); margin-bottom: 3px; }
  .keyhint kbd {
    background: var(--border); border-radius: 2px;
    padding: 1px 5px; color: var(--text); font-family: var(--font-main);
  }

  /* â”€â”€ NOTIFICATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #notifications {
    position: absolute; top: 14px; left: 50%;
    transform: translateX(-50%);
    display: flex; flex-direction: column;
    align-items: center; gap: 4px;
    pointer-events: none; z-index: 40;
  }
  .notif {
    background: rgba(10,12,15,0.9);
    border: 1px solid var(--border);
    border-radius: 2px; padding: 5px 14px;
    font-size: 0.75rem; letter-spacing: 0.1em;
    animation: notif-in 0.3s ease, notif-out 0.4s ease 2.6s forwards;
  }
  @keyframes notif-in  { from { opacity:0; transform:translateY(-8px); } to { opacity:1; transform:translateY(0); } }
  @keyframes notif-out { from { opacity:1; } to { opacity:0; } }

  /* â”€â”€ DEAD SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #dead-overlay {
    position: absolute; inset: 0;
    background: rgba(8,10,14,0.75);
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 30;
  }
  #dead-overlay.active { display: flex; }
  #dead-overlay h2 {
    font-family: var(--font-head); font-size: 2.5rem;
    color: var(--red); letter-spacing: 0.15em;
    margin-bottom: 0.5em;
  }
  #respawn-timer {
    font-size: 1rem; color: var(--dim);
    letter-spacing: 0.2em;
  }

  /* â”€â”€ MATCH OVER OVERLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #match-over-overlay {
    position: absolute; inset: 0;
    background: rgba(5,7,10,0.93);
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 60;
    backdrop-filter: blur(3px);
  }
  #match-over-overlay.active { display: flex; }
  #match-over-overlay .mo-title {
    font-family: var(--font-head);
    font-size: clamp(2rem, 5vw, 3.5rem);
    letter-spacing: 0.2em;
    color: var(--accent);
    text-shadow: 0 0 30px rgba(200,168,75,0.5);
    margin-bottom: 0.15em;
    text-transform: uppercase;
  }
  #match-over-overlay .mo-winner {
    font-size: 0.85rem;
    letter-spacing: 0.25em;
    color: var(--dim);
    margin-bottom: 1.8em;
    text-transform: uppercase;
  }
  #match-over-overlay .mo-winner span {
    font-weight: bold;
  }
  #mo-leaderboard {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 18px 28px;
    min-width: 320px;
    margin-bottom: 1.6em;
  }
  #mo-leaderboard .mo-lb-header {
    font-family: var(--font-head);
    font-size: 0.65rem;
    letter-spacing: 0.25em;
    color: var(--dim);
    text-transform: uppercase;
    border-bottom: 1px solid var(--border);
    padding-bottom: 8px;
    margin-bottom: 10px;
  }
  .mo-lb-row {
    display: flex; align-items: center; gap: 12px;
    padding: 6px 0;
    border-bottom: 1px solid rgba(30,40,50,0.5);
    font-size: 0.8rem;
  }
  .mo-lb-row:last-child { border-bottom: none; }
  .mo-lb-rank {
    font-family: var(--font-head);
    font-size: 1rem;
    width: 24px; text-align: center;
    color: var(--dim);
  }
  .mo-lb-rank.gold   { color: #f1c40f; }
  .mo-lb-rank.silver { color: #bdc3c7; }
  .mo-lb-rank.bronze { color: #e67e22; }
  .mo-lb-color { width:10px; height:10px; border-radius:50%; flex-shrink:0; }
  .mo-lb-name  { flex:1; color: var(--text); }
  .mo-lb-forts { color: var(--dim); font-size: 0.7rem; }
  .mo-lb-score { color: var(--accent); font-family: var(--font-head); font-size: 1rem; min-width:40px; text-align:right; }
  #mo-vote-section {
    display: flex; flex-direction: column; align-items: center; gap: 10px;
  }
  #mo-vote-btn {
    background: var(--accent);
    border: none; border-radius: 2px;
    color: #0a0c0f;
    font-family: var(--font-head);
    font-size: 1rem; font-weight: 600;
    letter-spacing: 0.15em;
    padding: 0.6em 2.2em;
    cursor: pointer;
    text-transform: uppercase;
    transition: background 0.15s, transform 0.1s, opacity 0.2s;
  }
  #mo-vote-btn:hover:not(:disabled) { background: #dbb85e; transform: scale(1.03); }
  #mo-vote-btn:disabled { opacity: 0.45; cursor: default; transform: none; }
  #mo-vote-status {
    font-size: 0.75rem;
    letter-spacing: 0.15em;
    color: var(--dim);
    text-transform: uppercase;
  }

  /* â”€â”€ MATCH TIMER HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #match-timer-hud {
    position: absolute; top: 14px; left: 50%;
    transform: translateX(-50%);
    background: rgba(10,12,15,0.85);
    border: 1px solid var(--border);
    border-radius: 2px;
    padding: 4px 18px;
    font-family: var(--font-head);
    font-size: 1rem;
    letter-spacing: 0.2em;
    color: var(--text);
    pointer-events: none;
    z-index: 10;
  }
  #match-timer-hud.urgent { color: var(--red); border-color: var(--red); }

  /* â”€â”€ SCROLL PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #lb-scroll { overflow-y: auto; padding: 12px 14px; }
  #lb-scroll::-webkit-scrollbar { width: 4px; }
  #lb-scroll::-webkit-scrollbar-track { background: var(--bg); }
  #lb-scroll::-webkit-scrollbar-thumb { background: var(--border); }

  /* â”€â”€ CHAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #chat-section {
    display: flex; flex-direction: column;
    border-top: 1px solid var(--border);
    flex-shrink: 0;
  }
  #chat-messages {
    overflow-y: auto; padding: 6px 10px;
    display: flex; flex-direction: column; gap: 3px;
    height: 160px;
  }
  #chat-messages::-webkit-scrollbar { width: 3px; }
  #chat-messages::-webkit-scrollbar-thumb { background: var(--border); }
  .chat-msg { font-size: 0.67rem; line-height: 1.4; word-break: break-word; }
  .chat-ts   { color: var(--dim); font-size: 0.58rem; margin-right: 3px; }
  .chat-name { font-weight: bold; margin-right: 3px; }
  .chat-text { color: var(--text); }
  .chat-msg.killfeed   .chat-text { color: #e74c3c; font-style: italic; }
  .chat-msg.capturefeed .chat-text { color: #2ecc71; font-style: italic; }
  #chat-input-row {
    display: flex;
    border-top: 1px solid var(--border);
  }
  #chat-input {
    flex: 1; background: transparent; border: none; outline: none;
    color: var(--text); font-family: var(--font-main);
    font-size: 0.72rem; padding: 6px 8px;
  }
  #chat-input::placeholder { color: var(--dim); }
  #chat-send {
    background: none; border: none;
    border-left: 1px solid var(--border);
    color: var(--accent); font-family: var(--font-main);
    font-size: 0.68rem; padding: 0 9px; cursor: pointer;
    transition: background 0.15s;
  }
  #chat-send:hover { background: rgba(200,168,75,0.1); }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MOBILE STYLES
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

  /* â”€â”€ Bottom resource HUD strip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #mobile-hud {
    display: none; position: absolute;
    bottom: 0; left: 0; right: 0; height: 58px;
    background: rgba(7,10,14,0.96);
    border-top: 1px solid var(--border);
    backdrop-filter: blur(8px);
    z-index: 20; padding: 0 10px;
    align-items: center; gap: 6px;
    touch-action: none;
  }
  .mob-res { display: flex; flex-direction: column; align-items: center; flex: 1; gap: 2px; }
  .mob-res-label { font-size: 0.52rem; letter-spacing: 0.1em; color: var(--dim); text-transform: uppercase; }
  .mob-res-bar-bg { width: 100%; height: 4px; background: var(--border); border-radius: 2px; overflow: hidden; }
  .mob-res-bar-fill { height: 100%; border-radius: 2px; transition: width 0.3s; }
  .mob-res-val { font-size: 0.6rem; color: var(--text); }

  /* â”€â”€ FAB buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #mobile-fabs {
    display: none; position: absolute;
    bottom: 66px; right: 12px;
    flex-direction: column; gap: 10px; z-index: 25;
  }
  .fab-btn {
    width: 50px; height: 50px; border-radius: 50%;
    border: 1px solid var(--border);
    background: rgba(10,12,15,0.94);
    color: var(--text); font-size: 1.25rem;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; position: relative;
    backdrop-filter: blur(4px);
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    transition: transform 0.1s, background 0.15s, border-color 0.15s;
    user-select: none;
  }
  .fab-btn:active { transform: scale(0.88); }

  /* â”€â”€ Attack hold reticle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #mob-hold-ring {
    display: none; position: absolute;
    width: 52px; height: 52px; border-radius: 50%;
    border: 3px solid var(--red);
    pointer-events: none; z-index: 30;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 12px rgba(231,76,60,0.5);
    animation: ring-pulse 0.4s ease infinite alternate;
  }
  @keyframes ring-pulse {
    from { box-shadow: 0 0 6px rgba(231,76,60,0.4); }
    to   { box-shadow: 0 0 18px rgba(231,76,60,0.8); }
  }
  #mob-hold-ring.visible { display: block; }

  /* â”€â”€ Mode pill â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #mobile-mode-pill {
    display: none; position: absolute;
    bottom: 66px; left: 50%; transform: translateX(-50%);
    background: rgba(10,12,15,0.9); border: 1px solid var(--border);
    border-radius: 20px; padding: 4px 14px;
    font-size: 0.65rem; letter-spacing: 0.15em;
    color: var(--dim); pointer-events: none;
    text-transform: uppercase; white-space: nowrap; z-index: 21;
  }
  #mobile-mode-pill.move-mode   { color: var(--green); border-color: var(--green); }
  #mobile-mode-pill.attack-mode { color: var(--red);   border-color: var(--red); }

  /* â”€â”€ Sidebar drawer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #mob-drawer-backdrop {
    display: none; position: fixed; inset: 0;
    background: rgba(0,0,0,0.55); z-index: 80;
  }
  #mob-drawer-backdrop.open { display: block; }
  #mob-drawer {
    position: fixed; top: 0; right: -100%;
    width: min(300px, 88vw); height: 100%;
    background: var(--panel); border-left: 1px solid var(--border);
    z-index: 81; display: flex; flex-direction: column;
    transition: right 0.26s cubic-bezier(0.4,0,0.2,1); overflow: hidden;
  }
  #mob-drawer.open { right: 0; }
  #mob-drawer-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 14px 16px; border-bottom: 1px solid var(--border);
    background: #070a0d; flex-shrink: 0;
  }
  #mob-drawer-header span { font-family: var(--font-head); font-size: 0.9rem; letter-spacing: 0.2em; color: var(--accent); }
  #mob-drawer-close {
    background: none; border: none; color: var(--dim);
    font-size: 1.3rem; cursor: pointer; padding: 4px 8px;
    -webkit-tap-highlight-color: transparent;
  }
  #mob-drawer-body {
    flex: 1; overflow-y: auto; padding: 14px;
    display: flex; flex-direction: column; gap: 16px;
  }
  #mob-drawer-body::-webkit-scrollbar { width: 3px; }
  #mob-drawer-body::-webkit-scrollbar-thumb { background: var(--border); }
  #mob-minimap-wrap { display: flex; justify-content: center; }
  #mob-minimap-canvas { border: 1px solid var(--border); border-radius: 2px; }
  .mob-drawer-title {
    font-family: var(--font-head); font-size: 0.65rem;
    letter-spacing: 0.2em; color: var(--dim);
    text-transform: uppercase; margin-bottom: 8px;
  }

  /* â”€â”€ Mobile chat overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #mob-chat-overlay {
    display: none; position: fixed;
    left: 0; right: 0; bottom: 0;
    background: rgba(7,10,14,0.97);
    border-top: 1px solid var(--border);
    z-index: 90; flex-direction: column;
    max-height: 55vh; backdrop-filter: blur(8px);
  }
  #mob-chat-overlay.open { display: flex; }
  #mob-chat-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 14px; border-bottom: 1px solid var(--border); flex-shrink: 0;
  }
  #mob-chat-header span { font-size: 0.72rem; letter-spacing: 0.12em; color: var(--dim); }
  #mob-chat-close {
    background: none; border: none; color: var(--dim);
    font-size: 1.2rem; cursor: pointer; padding: 2px 8px;
    -webkit-tap-highlight-color: transparent;
  }
  #mob-chat-messages {
    flex: 1; overflow-y: auto; padding: 8px 12px;
    display: flex; flex-direction: column; gap: 3px;
  }
  #mob-chat-messages::-webkit-scrollbar { width: 3px; }
  #mob-chat-messages::-webkit-scrollbar-thumb { background: var(--border); }
  #mob-chat-input-row {
    display: flex; border-top: 1px solid var(--border); flex-shrink: 0;
  }
  #mob-chat-input {
    flex: 1; background: transparent; border: none; outline: none;
    color: var(--text); font-family: var(--font-main);
    font-size: 1rem; padding: 10px 12px;
  }
  #mob-chat-input::placeholder { color: var(--dim); }
  #mob-chat-send {
    background: none; border: none; border-left: 1px solid var(--border);
    color: var(--accent); font-family: var(--font-main);
    font-size: 0.8rem; padding: 0 14px; cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  }

  /* unread badge */
  #mob-chat-badge {
    position: absolute; top: -4px; right: -4px;
    background: var(--red); border-radius: 50%;
    width: 17px; height: 17px; font-size: 0.58rem;
    color: #fff; display: none;
    align-items: center; justify-content: center;
    font-family: var(--font-head); pointer-events: none;
  }
  #mob-chat-badge.visible { display: flex; }

  @media (max-width: 700px) {
    #side-panel       { display: none !important; }
    #keyhints         { display: none !important; }
    #mode-indicator   { display: none !important; }
    #mobile-hud       { display: flex; }
    #mobile-fabs      { display: flex; }
    #mobile-mode-pill { display: block; }
    #canvas-container { padding-bottom: 58px; }
    #match-timer-hud  { top: 10px; font-size: 0.85rem; padding: 3px 12px; }
    #notifications    { top: 42px; }
    #upgrade-panel    { width: calc(100vw - 24px); max-height: 80vh; overflow-y: auto;
                        top: auto; bottom: 66px; left: 50%;
                        transform: translateX(-50%) scale(0.95);
                        transform-origin: bottom center; }
    #upgrade-panel.open { transform: translateX(-50%) scale(1); }
  }
</style>
</head>
<body>

<!-- LOGIN -->
<div id="login-screen">
  <h1>IRON FOG</h1>
  <div class="subtitle">Tactical Hex Warfare</div>
  <input id="name-input" type="text" placeholder="Commander name..." maxlength="20" autofocus>
  <button id="join-btn">DEPLOY</button>
  <div id="status-msg"></div>
</div>

<!-- GAME -->
<div id="game-wrapper">
  <div id="canvas-container">
    <canvas id="game-canvas"></canvas>

    <!-- HUD -->
    <div id="hud-top">
      <div id="tank-status"></div>
    </div>

    <div id="mode-indicator">IDLE</div>

    <div id="notifications"></div>

    <div id="keyhints">
      <div class="keyhint"><kbd>U</kbd> Upgrades</div>
      <div class="keyhint"><kbd>ESC</kbd> Cancel</div>
      <div class="keyhint"><kbd>LMB drag</kbd> Move</div>
      <div class="keyhint"><kbd>RMB drag</kbd> Attack</div>
    </div>

    <div id="dead-overlay">
      <h2>âš  DESTROYED</h2>
      <div id="respawn-timer">Respawning in â€¦</div>
    </div>

    <!-- MATCH TIMER -->
    <div id="match-timer-hud">10:00</div>

    <!-- MATCH OVER -->
    <div id="match-over-overlay">
      <div class="mo-title">MATCH OVER</div>
      <div class="mo-winner" id="mo-winner-line">Victory â€” <span id="mo-winner-name"></span></div>
      <div id="mo-leaderboard">
        <div class="mo-lb-header">Final Standings</div>
        <div id="mo-lb-rows"></div>
      </div>
      <div id="mo-vote-section">
        <button id="mo-vote-btn">â–¶ PLAY AGAIN</button>
        <div id="mo-vote-status">Waiting for votesâ€¦</div>
      </div>
    </div>

    <!-- MOBILE: bottom resource HUD -->
    <div id="mobile-hud">
      <div class="mob-res">
        <div class="mob-res-label">HP</div>
        <div class="mob-res-bar-bg"><div class="mob-res-bar-fill" id="mob-bar-hp" style="width:100%;background:#16a085"></div></div>
        <div class="mob-res-val" id="mob-val-hp">100</div>
      </div>
      <div class="mob-res">
        <div class="mob-res-label">FUEL</div>
        <div class="mob-res-bar-bg"><div class="mob-res-bar-fill" id="mob-bar-fuel" style="width:80%;background:#27ae60"></div></div>
        <div class="mob-res-val" id="mob-val-fuel">80</div>
      </div>
      <div class="mob-res">
        <div class="mob-res-label">AMMO</div>
        <div class="mob-res-bar-bg"><div class="mob-res-bar-fill" id="mob-bar-ammo" style="width:50%;background:#c0392b"></div></div>
        <div class="mob-res-val" id="mob-val-ammo">50</div>
      </div>
      <div class="mob-res">
        <div class="mob-res-label">GEARS</div>
        <div class="mob-res-bar-bg"><div class="mob-res-bar-fill" id="mob-bar-gear" style="width:0%;background:#c8a84b"></div></div>
        <div class="mob-res-val" id="mob-val-gear">0</div>
      </div>
    </div>

    <!-- MOBILE: mode pill -->
    <div id="mobile-mode-pill">TAP TO MOVE Â· HOLD TO FIRE</div>

    <!-- MOBILE: FAB buttons -->
    <div id="mobile-fabs">
      <div class="fab-btn" id="fab-upgrade" title="Upgrades">âš™ï¸</div>
      <div class="fab-btn" id="fab-map" title="Map &amp; Stats">ğŸ—ºï¸</div>
      <div class="fab-btn" id="fab-chat" title="Chat" style="position:relative;">
        ğŸ’¬<div id="mob-chat-badge"></div>
      </div>
      <div class="fab-btn" id="fab-center" title="Center on tank">âŠ•</div>
    </div>

  </div><!-- end canvas-container -->

  <!-- SIDE PANEL (desktop) -->
  <div id="side-panel">
    <div class="panel-section" style="background:#070a0d; padding:14px;">
      <div style="font-family:var(--font-head);font-size:1.1rem;letter-spacing:0.2em;color:var(--accent);">IRON FOG</div>
      <div id="player-name" style="font-size:0.7rem;color:var(--dim);margin-top:2px;"></div>
    </div>

    <div class="panel-section">
      <div class="panel-title">Tank Status</div>
      <div class="res-row">
        <span class="res-label">HP</span>
        <div class="res-bar-bg"><div class="res-bar-fill hp-bar" id="bar-hp" style="width:100%"></div></div>
        <span class="res-val" id="val-hp">100</span>
      </div>
      <div class="res-row">
        <span class="res-label">FUEL</span>
        <div class="res-bar-bg"><div class="res-bar-fill fuel-bar" id="bar-fuel" style="width:80%"></div></div>
        <span class="res-val" id="val-fuel">80</span>
      </div>
      <div class="res-row">
        <span class="res-label">AMMO</span>
        <div class="res-bar-bg"><div class="res-bar-fill ammo-bar" id="bar-ammo" style="width:50%"></div></div>
        <span class="res-val" id="val-ammo">50</span>
      </div>
      <div class="res-row">
        <span class="res-label">GEARS</span>
        <div class="res-bar-bg"><div class="res-bar-fill gear-bar" id="bar-gear" style="width:0%"></div></div>
        <span class="res-val" id="val-gear">0</span>
      </div>
    </div>

    <div class="panel-section">
      <div class="panel-title">Minimap</div>
      <canvas id="minimap-canvas" width="210" height="210"></canvas>
    </div>

    <div id="lb-scroll">
      <div class="panel-title">Leaderboard</div>
      <div id="leaderboard"></div>

      <div class="panel-title" style="margin-top:14px;">Forts</div>
      <div id="fort-info" style="font-size:0.7rem;color:var(--dim);line-height:1.8;"></div>
    </div>

    <!-- CHAT (desktop) -->
    <div id="chat-section">
      <div class="panel-title" style="padding:8px 10px 4px;margin:0;">ğŸ’¬ Chat</div>
      <div id="chat-messages"></div>
      <div id="chat-input-row">
        <input id="chat-input" type="text" placeholder="Say somethingâ€¦" maxlength="120" autocomplete="off">
        <button id="chat-send">SEND</button>
      </div>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MOBILE OVERLAYS (rendered outside game-wrapper)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

<!-- Attack hold ring (follows touch position) -->
<div id="mob-hold-ring"></div>

<!-- Sidebar drawer backdrop -->
<div id="mob-drawer-backdrop"></div>

<!-- Sidebar drawer -->
<div id="mob-drawer">
  <div id="mob-drawer-header">
    <span>IRON FOG</span>
    <button id="mob-drawer-close">âœ•</button>
  </div>
  <div id="mob-drawer-body">
    <div>
      <div class="mob-drawer-title">Minimap</div>
      <div id="mob-minimap-wrap">
        <canvas id="mob-minimap-canvas" width="240" height="240"></canvas>
      </div>
    </div>
    <div>
      <div class="mob-drawer-title">Leaderboard</div>
      <div id="mob-leaderboard"></div>
    </div>
    <div>
      <div class="mob-drawer-title">My Forts</div>
      <div id="mob-fort-info" style="font-size:0.7rem;color:var(--dim);line-height:1.8;"></div>
    </div>
  </div>
</div>

<!-- Mobile chat overlay -->
<div id="mob-chat-overlay">
  <div id="mob-chat-header">
    <span>ğŸ’¬ CHAT</span>
    <button id="mob-chat-close">âœ•</button>
  </div>
  <div id="mob-chat-messages"></div>
  <div id="mob-chat-input-row">
    <input id="mob-chat-input" type="text" placeholder="Say somethingâ€¦" maxlength="120" autocomplete="off" enterkeyhint="send">
    <button id="mob-chat-send">SEND</button>
  </div>
</div>

<!-- UPGRADE PANEL -->
<div id="upgrade-panel">
  <h2>âš™ Upgrades</h2>
  <div id="upgrade-list"></div>
  <button class="upg-close" id="close-upgrades">[ CLOSE ]</button>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  IRON FOG â€“ Client
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas  = document.getElementById('game-canvas');
const ctx     = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const minimap = document.getElementById('minimap-canvas');
const mctx    = minimap.getContext('2d');

// â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const HEX_SIZE    = 40;        // pixels
const MAP_RADIUS  = 8;
// Everything is on one port - WS connects to same host the page loaded from
const WS_PROTO = location.protocol === 'https:' ? 'wss:' : 'ws:';
const WS_URL   = `${WS_PROTO}//${location.host}`;

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let ws           = null;
let myPlayerId   = null;
let myName       = '';
let gameState    = null;
let upgradeData     = {};
let upgradeMaxLevel = 3;

// camera
let camX = 0, camY = 0;
let camScale = 1.0;
let isPanning = false, panStart = null, camAtPan = null;

// drag state
let isDragging   = false;
let dragMode     = null; // 'move' | 'attack'
let dragStart    = null; // {q,r} hex
let dragCurrent  = null; // current mouse hex
let dragPath     = [];   // computed path for move
let dragLine     = null; // {q,r} for attack endpoint

// assets
const assets = {};
function loadAsset(name, src) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload  = () => { assets[name] = img; resolve(); };
    img.onerror = () => { assets[name] = null; resolve(); };
    img.src = src;
  });
}

// â”€â”€ Hex Math â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function hexToPixel(q, r, scale=1) {
  const s = HEX_SIZE * scale;
  const x = s * (3/2 * q);
  const y = s * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
  return {x, y};
}
function pixelToHex(x, y, scale=1) {
  const s = HEX_SIZE * scale;
  const q = (2/3 * x) / s;
  const r = (-1/3 * x + Math.sqrt(3)/3 * y) / s;
  return hexRound(q, r);
}
function hexRound(q, r) {
  let x=q, z=r, y=-x-z;
  let rx=Math.round(x), ry=Math.round(y), rz=Math.round(z);
  const dx=Math.abs(rx-x), dy=Math.abs(ry-y), dz=Math.abs(rz-z);
  if (dx>dy && dx>dz) rx=-ry-rz;
  else if (dy>dz) ry=-rx-rz;
  else rz=-rx-ry;
  return {q:rx, r:rz};
}
function hexDistance(a, b) {
  return (Math.abs(a.q-b.q) + Math.abs(a.q+a.r-b.q-b.r) + Math.abs(a.r-b.r)) / 2;
}
function hexNeighbors(q, r) {
  const dirs=[[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
  return dirs.map(([dq,dr])=>({q:q+dq,r:r+dr}));
}
function inMapRange(q, r) {
  return hexDistance({q:0,r:0},{q,r}) <= MAP_RADIUS;
}

// BFS pathfinding
function hexPathfind(start, end) {
  const key = h => `${h.q},${h.r}`;
  const frontier = [start];
  const came = new Map();
  came.set(key(start), null);
  while (frontier.length) {
    const cur = frontier.shift();
    if (cur.q===end.q && cur.r===end.r) {
      // reconstruct
      const path = [];
      let c = end;
      while (c) { path.unshift(c); c = came.get(key(c)); }
      return path.slice(1); // exclude start
    }
    for (const nb of hexNeighbors(cur.q, cur.r)) {
      if (!inMapRange(nb.q, nb.r)) continue;
      if (!came.has(key(nb))) {
        came.set(key(nb), cur);
        frontier.push(nb);
      }
    }
  }
  return [];
}

// â”€â”€ Canvas Resize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resizeCanvas() {
  const container = canvas.parentElement;
  canvas.width  = container.clientWidth;
  canvas.height = container.clientHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// â”€â”€ Transform helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function worldToScreen(wx, wy) {
  return {
    x: (wx - camX) * camScale + canvas.width/2,
    y: (wy - camY) * camScale + canvas.height/2,
  };
}
function screenToWorld(sx, sy) {
  return {
    x: (sx - canvas.width/2) / camScale + camX,
    y: (sy - canvas.height/2) / camScale + camY,
  };
}
function screenToHex(sx, sy) {
  const w = screenToWorld(sx, sy);
  return pixelToHex(w.x, w.y);
}

// â”€â”€ Draw Hex â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Flat-top hex: corner angles start at 0Â° (right), step 60Â°
function hexPath(cx, cy, size) {
  const path = new Path2D();
  for (let i = 0; i < 6; i++) {
    const a = (Math.PI / 3) * i;   // 0Â°, 60Â°, 120Â°, 180Â°, 240Â°, 300Â° â€” flat-top
    const x = cx + size * Math.cos(a);
    const y = cy + size * Math.sin(a);
    if (i === 0) path.moveTo(x, y); else path.lineTo(x, y);
  }
  path.closePath();
  return path;
}

function drawHex(q, r, fillColor, strokeColor, alpha=1, size=null) {
  const s = size || HEX_SIZE;
  const p = hexToPixel(q, r);
  const sc = worldToScreen(p.x, p.y);
  const drawSize = s * camScale;
  if (drawSize < 2) return;
  // Use a 1px inset purely for the stroke gap â€” fill uses full size
  const fillPath   = hexPath(sc.x, sc.y, drawSize);
  const strokePath = hexPath(sc.x, sc.y, drawSize - 0.5);
  ctx.globalAlpha = alpha;
  if (fillColor) {
    ctx.fillStyle = fillColor;
    ctx.fill(fillPath);
  }
  if (strokeColor) {
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 1;
    ctx.stroke(strokePath);
  }
  ctx.globalAlpha = 1;
}

// â”€â”€ Fort colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FORT_COLORS = {
  fuel:  '#27ae60',
  ammo:  '#c0392b',
  gear:  '#c8a84b',
  mixed: '#8e44ad',
};

// â”€â”€ Main Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#0a0c0f';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (!gameState) {
    requestAnimationFrame(render);
    return;
  }

  const myTank = gameState.tanks[myPlayerId];
  const visibleSet = new Set(gameState.visible_hexes.map(h=>`${h[0]},${h[1]}`));

  // â”€â”€ Draw base hex grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (let dq=-MAP_RADIUS; dq<=MAP_RADIUS; dq++) {
    for (let dr=Math.max(-MAP_RADIUS,-dq-MAP_RADIUS); dr<=Math.min(MAP_RADIUS,-dq+MAP_RADIUS); dr++) {
      const key = `${dq},${dr}`;
      const visible = visibleSet.has(key);
      if (visible) {
        drawHex(dq, dr, '#0d1117', '#1e2832', 1);
      } else {
        drawHex(dq, dr, '#070a0e', '#0f1318', 0.7);
      }
    }
  }

  // â”€â”€ Drag path highlight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (isDragging && dragMode === 'move' && dragPath.length > 0) {
    for (const h of dragPath) {
      drawHex(h.q, h.r, 'rgba(46,204,113,0.18)', '#2ecc71', 0.9);
    }
    // draw line from tank to cursor
    if (myTank) {
      const startPx = hexToPixel(myTank.q, myTank.r);
      const ss = worldToScreen(startPx.x, startPx.y);
      const endH = dragPath[dragPath.length-1];
      const endPx = hexToPixel(endH.q, endH.r);
      const es = worldToScreen(endPx.x, endPx.y);
      ctx.beginPath();
      ctx.moveTo(ss.x, ss.y);
      ctx.lineTo(es.x, es.y);
      ctx.strokeStyle = 'rgba(46,204,113,0.5)';
      ctx.lineWidth = 2;
      ctx.setLineDash([6,4]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  if (isDragging && dragMode === 'attack' && dragCurrent) {
    // draw attack reticle
    drawHex(dragCurrent.q, dragCurrent.r, 'rgba(231,76,60,0.25)', '#e74c3c', 0.9);
    if (myTank) {
      const startPx = hexToPixel(myTank.q, myTank.r);
      const ss = worldToScreen(startPx.x, startPx.y);
      const endPx = hexToPixel(dragCurrent.q, dragCurrent.r);
      const es = worldToScreen(endPx.x, endPx.y);
      ctx.beginPath();
      ctx.moveTo(ss.x, ss.y);
      ctx.lineTo(es.x, es.y);
      ctx.strokeStyle = 'rgba(231,76,60,0.7)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4,3]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  // â”€â”€ Draw forts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (const [fid, fort] of Object.entries(gameState.forts)) {
    const key = `${fort.q},${fort.r}`;
    const visible = visibleSet.has(key);
    if (!visible && fort.owner !== myPlayerId) continue;

    const baseColor = FORT_COLORS[fort.ftype] || '#8e44ad';
    const owned = fort.owner ? baseColor : '#1e2832';
    drawHex(fort.q, fort.r, owned+'22', baseColor, 0.85);

    // capture progress arc
    if (fort.capture_progress > 0 && fort.capturing_player) {
      const p = hexToPixel(fort.q, fort.r);
      const sc = worldToScreen(p.x, p.y);
      const capColor = fort.capturing_player === myPlayerId ? '#2ecc71' : '#e74c3c';

      // Match server: recaptured forts (was_owned) take 1.5x longer
      const CAPTURE_TIME = 5.0;
      const RECAPTURE_MULTIPLIER = 1.5;
      const effectiveCaptureTime = CAPTURE_TIME * (fort.was_owned ? RECAPTURE_MULTIPLIER : 1.0);
      const progress = Math.min(fort.capture_progress / effectiveCaptureTime, 1.0);

      // Background ring (shows total time remaining)
      ctx.beginPath();
      ctx.arc(sc.x, sc.y, HEX_SIZE * camScale * 0.55, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 3 * camScale;
      ctx.stroke();

      // Filled arc showing actual progress
      ctx.beginPath();
      ctx.arc(sc.x, sc.y, HEX_SIZE * camScale * 0.55,
        -Math.PI / 2,
        -Math.PI / 2 + progress * Math.PI * 2);
      ctx.strokeStyle = capColor;
      ctx.lineWidth = 3 * camScale;
      ctx.stroke();

      // Show a small lock icon / indicator on recapture forts so player knows it's slower
      if (fort.was_owned && camScale > 0.5) {
        ctx.font = `${Math.max(8, 10 * camScale)}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.globalAlpha = 0.7;
        ctx.fillText('ğŸ”’', sc.x + HEX_SIZE * camScale * 0.5, sc.y - HEX_SIZE * camScale * 0.5);
        ctx.globalAlpha = 1;
      }
    }

    // fort icon
    const p = hexToPixel(fort.q, fort.r);
    const sc = worldToScreen(p.x, p.y);
    const iconSize = Math.max(10, HEX_SIZE * camScale * 0.9);
    ctx.font = `${iconSize}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const img = assets['fort_' + fort.ftype];
    if (img) {
      ctx.drawImage(img, sc.x - iconSize/2, sc.y - iconSize/2, iconSize, iconSize);
    } else {
      ctx.fillText('ğŸ›', sc.x, sc.y);
    }


    // owner dot
    if (fort.owner && gameState.tanks[fort.owner]) {
      ctx.fillStyle = gameState.tanks[fort.owner].color;
      ctx.beginPath();
      ctx.arc(sc.x + HEX_SIZE*camScale*0.4, sc.y - HEX_SIZE*camScale*0.4, 5*camScale, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // â”€â”€ Draw fog overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (let dq=-MAP_RADIUS; dq<=MAP_RADIUS; dq++) {
    for (let dr=Math.max(-MAP_RADIUS,-dq-MAP_RADIUS); dr<=Math.min(MAP_RADIUS,-dq+MAP_RADIUS); dr++) {
      if (!visibleSet.has(`${dq},${dr}`)) {
        drawHex(dq, dr, 'rgba(8,12,18,0.72)', null, 1);
      }
    }
  }

  // â”€â”€ Draw tanks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (const [pid, tank] of Object.entries(gameState.tanks)) {
    if (!tank.alive) continue;
    const p = hexToPixel(tank.q, tank.r);
    const sc = worldToScreen(p.x, p.y);
    const ts = HEX_SIZE * camScale * 0.5;

    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.ellipse(sc.x, sc.y + ts*0.3, ts*0.7, ts*0.22, 0, 0, Math.PI*2);
    ctx.fill();

    // Try to draw asset, fallback to shape
    const assetKey = pid === myPlayerId ? 'tank_self' : 'tank_enemy';
    const img = assets[assetKey];
    ctx.save();
    ctx.translate(sc.x, sc.y);
    ctx.rotate(tank.facing + Math.PI/2);
    if (img) {
      ctx.drawImage(img, -ts, -ts, ts*2, ts*2);
    } else {
      // draw tank shape programmatically
      const c = tank.color || '#e74c3c';
      // body
      ctx.fillStyle = c;
      ctx.beginPath();
      ctx.roundRect(-ts*0.4, -ts*0.55, ts*0.8, ts*1.1, ts*0.08);
      ctx.fill();
      // turret
      ctx.fillStyle = c;
      ctx.beginPath();
      ctx.arc(0, 0, ts*0.28, 0, Math.PI*2);
      ctx.fill();
      // barrel
      ctx.fillStyle = '#222';
      ctx.fillRect(-ts*0.065, -ts*0.65, ts*0.13, ts*0.55);
      // tracks
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(-ts*0.5, -ts*0.55, ts*0.13, ts*1.1);
      ctx.fillRect( ts*0.37, -ts*0.55, ts*0.13, ts*1.1);
    }
    ctx.restore();

    // HP bar
    if (tank.alive && tank.hp < tank.max_hp) {
      const bw = ts*1.4;
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(sc.x - bw/2, sc.y - ts - 8*camScale, bw, 4*camScale);
      ctx.fillStyle = '#27ae60';
      ctx.fillRect(sc.x - bw/2, sc.y - ts - 8*camScale, bw*(tank.hp/tank.max_hp), 4*camScale);
    }

    // name tag
    if (camScale > 0.6) {
      ctx.fillStyle = pid===myPlayerId ? '#fff' : tank.color;
      ctx.font = `${Math.max(9, 11*camScale)}px 'Share Tech Mono'`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      const nameText = pid===myPlayerId ? 'â–¶ YOU' : (gameState.leaderboard.find(l=>l.pid===pid)||{}).name||'?';
      ctx.fillText(nameText, sc.x, sc.y - ts - 10*camScale);
    }

    // movement path line
    if (pid === myPlayerId && tank.path && tank.path.length > 0) {
      ctx.beginPath();
      ctx.moveTo(sc.x, sc.y);
      for (const [pq, pr] of tank.path) {
        const pp = hexToPixel(pq, pr);
        const ps = worldToScreen(pp.x, pp.y);
        ctx.lineTo(ps.x, ps.y);
      }
      ctx.strokeStyle = 'rgba(46,204,113,0.35)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([5,4]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  // â”€â”€ Draw shells â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (const [sid, shell] of Object.entries(gameState.shells)) {
    const p = hexToPixel(shell.q, shell.r);
    const sc = worldToScreen(p.x, p.y);
    const r = 5 * camScale;

    ctx.fillStyle = '#f1c40f';
    ctx.beginPath();
    ctx.arc(sc.x, sc.y, r, 0, Math.PI*2);
    ctx.fill();

    // trail
    ctx.fillStyle = 'rgba(241,196,15,0.3)';
    ctx.beginPath();
    ctx.arc(sc.x - (shell.target_q-shell.q)*0.15*HEX_SIZE*camScale,
            sc.y - (shell.target_r-shell.r)*0.15*HEX_SIZE*camScale,
            r*1.5, 0, Math.PI*2);
    ctx.fill();
  }

  // â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const now = performance.now();
  const dt = Math.min(0.05, (now - lastParticleTime) / 1000);
  lastParticleTime = now;

  if (gameState) {
    for (const [sid, ps] of Object.entries(prevShells)) {
      if (!gameState.shells[sid]) {
        const ipx = hexToPixel(ps.target_q, ps.target_r);
        spawnExplosion(ipx.x, ipx.y, '#f39c12', 22);
      }
    }
    prevShells = {};
    for (const [sid, s] of Object.entries(gameState.shells)) {
      prevShells[sid] = s;
    }
  }

  updateParticles(dt);
  drawParticles();

  // â”€â”€ Minimap â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderMinimap(visibleSet);

  requestAnimationFrame(render);
}

function renderMinimap(visibleSet) {
  const W = minimap.width, H = minimap.height;
  mctx.fillStyle = '#060910';
  mctx.fillRect(0, 0, W, H);

  const S = W / (MAP_RADIUS*2.2) / 1.73;
  const cx = W/2, cy = H/2;

  function mHexToPixel(q,r) {
    return {
      x: cx + S*(3/2*q),
      y: cy + S*(Math.sqrt(3)/2*q + Math.sqrt(3)*r)
    };
  }

  // map hexes
  for (let dq=-MAP_RADIUS; dq<=MAP_RADIUS; dq++) {
    for (let dr=Math.max(-MAP_RADIUS,-dq-MAP_RADIUS); dr<=Math.min(MAP_RADIUS,-dq+MAP_RADIUS); dr++) {
      const p = mHexToPixel(dq,dr);
      mctx.fillStyle = visibleSet.has(`${dq},${dr}`) ? '#0d1117' : '#070a0e';
      mctx.beginPath();
      for (let i=0;i<6;i++){
        const a=(Math.PI/3)*i;   // flat-top: 0Â°,60Â°,120Â°...
        const x=p.x+(S-0.5)*Math.cos(a), y=p.y+(S-0.5)*Math.sin(a);
        if(i===0)mctx.moveTo(x,y);else mctx.lineTo(x,y);
      }
      mctx.closePath(); mctx.fill();
    }
  }

  // forts
  for (const fort of Object.values(gameState.forts)) {
    const p = mHexToPixel(fort.q, fort.r);
    const baseColor = FORT_COLORS[fort.ftype] || '#8e44ad';
    mctx.fillStyle = fort.owner ? baseColor : baseColor+'66';
    mctx.beginPath();
    mctx.arc(p.x, p.y, S*0.4, 0, Math.PI*2);
    mctx.fill();
  }

  // tanks
  for (const [pid, tank] of Object.entries(gameState.tanks)) {
    if (!tank.alive) continue;
    const p = mHexToPixel(tank.q, tank.r);
    mctx.fillStyle = tank.color;
    mctx.beginPath();
    mctx.arc(p.x, p.y, pid===myPlayerId ? S*0.65 : S*0.45, 0, Math.PI*2);
    mctx.fill();
    if (pid===myPlayerId) {
      mctx.strokeStyle = '#fff';
      mctx.lineWidth = 1;
      mctx.stroke();
    }
  }
}

// â”€â”€ UI Updates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateUI() {
  if (!gameState || !myPlayerId) return;

  const tank = gameState.tanks[myPlayerId];
  if (!tank) return;

  // â”€â”€ Match timer HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const timerEl = document.getElementById('match-timer-hud');
  if (timerEl && !gameState.match_over) {
    const t = Math.max(0, Math.ceil(gameState.match_timer || 0));
    const mins = Math.floor(t / 60);
    const secs = t % 60;
    timerEl.textContent = `${mins}:${secs.toString().padStart(2,'0')}`;
    timerEl.className = t <= 30 ? 'urgent' : '';
    timerEl.style.display = '';
  } else if (timerEl) {
    timerEl.style.display = 'none';
  }

  // â”€â”€ Match over overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const moOverlay = document.getElementById('match-over-overlay');
  if (gameState.match_over) {
    moOverlay.classList.add('active');

    // Winner line
    const winnerName = document.getElementById('mo-winner-name');
    const winnerLine = document.getElementById('mo-winner-line');
    if (gameState.winner_name) {
      winnerName.textContent = gameState.winner_name;
      winnerName.style.color = gameState.winner_color || 'var(--accent)';
      winnerLine.style.display = '';
    } else {
      winnerLine.style.display = 'none';
    }

    // Final leaderboard rows
    const rowsEl = document.getElementById('mo-lb-rows');
    const rankLabels = ['gold','silver','bronze'];
    rowsEl.innerHTML = (gameState.leaderboard || []).map((l, i) => `
      <div class="mo-lb-row">
        <div class="mo-lb-rank ${rankLabels[i]||''}">${i===0?'ğŸ¥‡':i===1?'ğŸ¥ˆ':i===2?'ğŸ¥‰':i+1}</div>
        <div class="mo-lb-color" style="background:${l.color}"></div>
        <span class="mo-lb-name">${escHtml(l.name)}</span>
        <span class="mo-lb-forts">${l.forts}âš‘</span>
        <span class="mo-lb-score">${l.score}</span>
      </div>
    `).join('');

    // Vote section
    const votes = gameState.votes || {cast:0, total:1, my_voted:false};
    const voteBtn = document.getElementById('mo-vote-btn');
    const voteStatus = document.getElementById('mo-vote-status');

    voteBtn.disabled = votes.my_voted;
    voteBtn.textContent = votes.my_voted ? 'âœ“ VOTED' : 'â–¶ PLAY AGAIN';
    voteStatus.textContent = `${votes.cast} / ${votes.total} players ready`;

    // Dead overlay should be hidden during match over
    document.getElementById('dead-overlay').classList.remove('active');
    return;
  } else {
    moOverlay.classList.remove('active');
  }

  // â”€â”€ Normal in-game UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (tank.alive) {
    document.getElementById('dead-overlay').classList.remove('active');
    // resources
    setBar('hp',   tank.hp   || 0, tank.max_hp || 100, '#16a085');
    setBar('fuel', tank.fuel || 0, 200, '#27ae60');
    setBar('ammo', tank.ammo || 0, 150, '#c0392b');
    setBar('gear', tank.gears|| 0, 99,  '#c8a84b');
  } else {
    document.getElementById('dead-overlay').classList.add('active');
    document.getElementById('respawn-timer').textContent =
      `Respawning in ${Math.ceil(tank.respawn_timer || 0)}sâ€¦`;
  }

  // leaderboard
  const lb = document.getElementById('leaderboard');
  lb.innerHTML = (gameState.leaderboard||[]).map(l=>`
    <div class="lb-row">
      <div class="lb-color" style="background:${l.color}"></div>
      <span class="lb-name">${escHtml(l.name)}</span>
      <span class="lb-forts">${l.forts}âš‘</span>
      <span class="lb-score">${l.score}</span>
    </div>
  `).join('');

  // fort stats
  const myForts = Object.values(gameState.forts).filter(f=>f.owner===myPlayerId);
  const fi = document.getElementById('fort-info');
  fi.innerHTML = myForts.length === 0
    ? '<span>No forts controlled</span>'
    : myForts.map(f=>`<div>âš‘ ${f.ftype.toUpperCase()} at (${f.q},${f.r})</div>`).join('');
}

function setBar(name, val, max, color) {
  const pct = Math.max(0, Math.min(100, (val/max)*100));
  const bar = document.getElementById(`bar-${name}`);
  const lbl = document.getElementById(`val-${name}`);
  if (bar) { bar.style.width = pct+'%'; bar.style.background = color; }
  if (lbl) lbl.textContent = Math.floor(val);
}

function setMode(mode) {
  const el = document.getElementById('mode-indicator');
  el.textContent = mode.toUpperCase();
  el.className = '';
  if (mode === 'move') el.classList.add('move-mode');
  if (mode === 'attack') el.classList.add('attack-mode');
}

// â”€â”€ Notifications â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function notify(msg, color='') {
  const el = document.createElement('div');
  el.className = 'notif';
  el.textContent = msg;
  if (color) el.style.borderColor = color;
  const container = document.getElementById('notifications');
  container.appendChild(el);
  setTimeout(() => el.remove(), 3000);
}

// â”€â”€ Chat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fmtTime(ts) {
  const d = new Date(ts * 1000);
  return `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
}

function addChatMsg(msg) {
  const box = document.getElementById('chat-messages');
  const el  = document.createElement('div');

  if (msg.kind === 'chat') {
    el.className = 'chat-msg';
    el.innerHTML = `<span class="chat-ts">${fmtTime(msg.ts)}</span>`
      + `<span class="chat-name" style="color:${escHtml(msg.color)}">${escHtml(msg.name)}:</span>`
      + `<span class="chat-text">${escHtml(msg.text)}</span>`;
  } else if (msg.kind === 'killfeed') {
    el.className = 'chat-msg killfeed';
    el.innerHTML = `<span class="chat-ts">${fmtTime(msg.ts)}</span>`
      + `<span class="chat-text">`
      + `<span style="color:${escHtml(msg.killerColor)}">${escHtml(msg.killer)}</span>`
      + ` â˜  `
      + `<span style="color:${escHtml(msg.victimColor)}">${escHtml(msg.victim)}</span>`
      + `</span>`;
  } else if (msg.kind === 'capturefeed') {
    el.className = 'chat-msg capturefeed';
    el.innerHTML = `<span class="chat-ts">${fmtTime(msg.ts)}</span>`
      + `<span class="chat-text">`
      + `<span style="color:${escHtml(msg.color)}">${escHtml(msg.name)}</span>`
      + ` captured ${escHtml(msg.fortType)} fort`
      + `</span>`;
  }

  box.appendChild(el);
  // Keep scrolled to bottom
  box.scrollTop = box.scrollHeight;
  // Max 80 messages
  while (box.children.length > 80) box.removeChild(box.firstChild);
}

function sendChat() {
  const input = document.getElementById('chat-input');
  const text  = input.value.trim();
  if (!text || !myPlayerId) return;
  sendMsg({type: 'chat', text});
  input.value = '';
}

document.getElementById('chat-send').addEventListener('click', sendChat);
document.getElementById('chat-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') { e.preventDefault(); sendChat(); }
  // Prevent game shortcuts firing while typing
  e.stopPropagation();
});

// â”€â”€ Upgrade Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderUpgrades() {
  const tank = gameState?.tanks?.[myPlayerId];
  const list = document.getElementById('upgrade-list');
  if (!upgradeData || !tank) { list.innerHTML = '<div style="color:var(--dim)">Loadingâ€¦</div>'; return; }

  const maxLvl = upgradeMaxLevel || 3;
  const lvlCosts = [5, 10, 18];

  list.innerHTML = Object.entries(upgradeData).map(([key, info])=>{
    const level    = tank.upgrades?.[key] || 0;
    const isMax    = level >= maxLvl;
    const nextCost = isMax ? 0 : lvlCosts[level];
    const canAfford = !isMax && (tank.gears||0) >= nextCost;

    const bars = Array.from({length: maxLvl}, (_,i) =>
      `<span style="display:inline-block;width:10px;height:10px;border-radius:2px;margin-right:2px;background:${i < level ? 'var(--accent)' : 'var(--border)'}"></span>`
    ).join('');

    return `
      <div class="upg-item" data-key="${key}" style="${isMax?'opacity:0.5;cursor:default':canAfford?'':'opacity:0.45;cursor:not-allowed'}">
        <span class="upg-name">${key.toUpperCase()}</span>
        <span class="upg-level">${bars}</span>
        <span class="upg-cost">${isMax ? '<span style="color:var(--green)">MAX</span>' : nextCost+'âš™'}</span>
      </div>
    `;
  }).join('');

  list.querySelectorAll('.upg-item').forEach(el => {
    el.addEventListener('click', () => {
      const key   = el.dataset.key;
      const level = tank.upgrades?.[key] || 0;
      if (level >= maxLvl) return;
      sendMsg({type:'upgrade', upgrade_type:key});
    });
  });
}

// â”€â”€ WebSocket â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sendMsg(data) {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify(data));
  }
}

function connect(name) {
  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    sendMsg({type:'join', name});
    document.getElementById('status-msg').textContent = '';
  };

  ws.onmessage = (ev) => {
    const data = JSON.parse(ev.data);
    handleServerMsg(data);
  };

  ws.onerror = () => {
    document.getElementById('status-msg').textContent = 'âš  Cannot connect to server. Is it running?';
    document.getElementById('login-screen').style.display = 'flex';
    document.getElementById('game-wrapper').classList.remove('active');
  };

  ws.onclose = () => {
    notify('Disconnected from server', '#e74c3c');
  };
}

function handleServerMsg(data) {
  switch(data.type) {
    case 'joined':
      myPlayerId      = data.player_id;
      upgradeData     = data.upgrades || {};
      upgradeMaxLevel = data.upgrade_max_level || 3;
      document.getElementById('player-name').textContent = myName;
      document.getElementById('login-screen').style.display = 'none';
      document.getElementById('game-wrapper').classList.add('active');
      resizeCanvas();
      // reset camera
      camX=0; camY=0; camScale=1.0;
      notify(`Welcome, ${myName}!`, '#2ecc71');
      break;

    case 'state':
      gameState = data;
      updateUI();
      break;

    case 'shoot_ack':
      if (data.error) notify('âš  '+data.error, '#e74c3c');
      break;

    case 'upgrade_ack':
      if (data.error) notify('âš  '+data.error, '#e74c3c');
      else {notify(`â†‘ ${data.upgrade?.toUpperCase()} upgraded to Lv.${data.level}`, '#c8a84b');
          renderUpgrades();   // refresh once 
          }
      if (document.getElementById('upgrade-panel').classList.contains('open')) renderUpgrades();
      break;

    case 'move_ack':
      if (data.error) notify('âš  '+data.error, '#e74c3c');
      break;

    case 'player_joined':
      notify(`${data.name} joined the battle`, data.color||'#fff');
      addChatMsg({kind:'capturefeed', color: data.color||'#fff', name: data.name,
                  fortType: 'the battle', ts: Date.now()/1000});
      break;

    case 'player_left':
      notify('A commander left the battlefield', '#888');
      addChatMsg({kind:'capturefeed', color:'#888', name:'A commander',
                  fortType: 'the battlefield (left)', ts: Date.now()/1000});
      break;

    case 'chat':
      addChatMsg({
        kind: 'chat',
        name: data.name, color: data.color,
        text: data.text, ts: data.ts,
      });
      break;

    case 'killfeed':
      addChatMsg({
        kind: 'killfeed',
        killerColor: data.killer_color, killer: data.killer,
        victimColor: data.victim_color, victim: data.victim,
        ts: data.ts,
      });
      break;

    case 'capturefeed':
      addChatMsg({
        kind: 'capturefeed',
        color: data.color, name: data.player,
        fortType: data.fort_type, ts: data.ts,
      });
      break;

    case 'match_over':
      // Server broadcasts this â€” state update handles the overlay,
      // but we play a notification here
      notify('â± MATCH OVER â€” Scores locked!', '#c8a84b');
      break;

    case 'vote_ack':
      if (data.error) notify('âš  '+data.error, '#e74c3c');
      else {
        const v = data;
        document.getElementById('mo-vote-status').textContent =
          `${v.voted} / ${v.total} players ready`;
        if (v.voted >= v.total) notify('All players voted â€” starting new match!', '#2ecc71');
      }
      break;

    case 'error':
      notify('âš  '+data.msg, '#e74c3c');
      if (data.msg === 'Game full') {
        document.getElementById('status-msg').textContent = 'âš  Game is full!';
      }
      break;
  }
}

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('mousedown', e => {
  if (!myPlayerId || !gameState) return;
  const tank = gameState.tanks[myPlayerId];

  // Middle mouse or space = pan
  if (e.button === 1) {
    isPanning = true;
    panStart = {x:e.clientX, y:e.clientY};
    camAtPan = {x:camX, y:camY};
    return;
  }

  if (!tank || !tank.alive) return;

  const hex = screenToHex(e.clientX - canvas.getBoundingClientRect().left,
                          e.clientY - canvas.getBoundingClientRect().top);
  // Only start drag from tank's hex
  const tankHex = {q:Math.round(tank.q), r:Math.round(tank.r)};

  isDragging = true;
  dragMode = e.button === 2 ? 'attack' : 'move';
  dragStart = tankHex;
  dragCurrent = hex;

  if (dragMode === 'move') {
    dragPath = hexPathfind(tankHex, hex);
    setMode('move');
  } else {
    setMode('attack');
  }
});

canvas.addEventListener('mousemove', e => {
  if (isPanning && panStart) {
    const dx = (e.clientX - panStart.x) / camScale;
    const dy = (e.clientY - panStart.y) / camScale;
    camX = camAtPan.x - dx;
    camY = camAtPan.y - dy;
    return;
  }

  if (!isDragging) return;
  const rect = canvas.getBoundingClientRect();
  const hex = screenToHex(e.clientX - rect.left, e.clientY - rect.top);
  dragCurrent = hex;

  if (dragMode === 'move' && dragStart) {
    const tank = gameState?.tanks?.[myPlayerId];
    if (!tank) return;
    const tankHex = {q:Math.round(tank.q), r:Math.round(tank.r)};
    dragPath = hexPathfind(tankHex, hex);
  }
});

canvas.addEventListener('mouseup', e => {
  if (isPanning) { isPanning = false; panStart = null; return; }
  if (!isDragging) return;

  const rect = canvas.getBoundingClientRect();
  const hex = screenToHex(e.clientX - rect.left, e.clientY - rect.top);
  const tank = gameState?.tanks?.[myPlayerId];

  if (dragMode === 'move' && dragPath.length > 0) {
    if (tank && tank.alive) {
      const pathData = dragPath.map(h=>[h.q, h.r]);
      sendMsg({type:'move', path:pathData});
    }
  } else if (dragMode === 'attack') {
    if (tank && tank.alive) {
      sendMsg({type:'shoot', target_q:hex.q, target_r:hex.r});
    }
  }

  isDragging = false;
  dragMode = null;
  dragPath = [];
  dragCurrent = null;
  setMode('idle');
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const zoomFactor = e.deltaY < 0 ? 1.1 : 0.91;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const before = screenToWorld(mx, my);
  camScale = Math.max(0.3, Math.min(3.0, camScale * zoomFactor));
  const after = screenToWorld(mx, my);
  camX += before.x - after.x;
  camY += before.y - after.y;
}, {passive:false});

// Keyboard shortcuts
document.addEventListener('keydown', e => {
  if (!myPlayerId) return;
  switch(e.key.toLowerCase()) {
    case 'u':
      toggleUpgrades(); break;
    case 'escape':
      isDragging = false; dragPath = []; dragMode = null; setMode('idle');
      document.getElementById('upgrade-panel').classList.remove('open');
      break;
    case ' ':
      e.preventDefault();
      // center camera on own tank
      if (gameState?.tanks?.[myPlayerId]) {
        const t = gameState.tanks[myPlayerId];
        const p = hexToPixel(t.q, t.r);
        camX = p.x; camY = p.y;
      }
      break;
    case 'h':
      notify('IRON FOG Controls: LMB drag=Move, RMB drag=Attack, U=Upgrades, SPACE=Center');
      break;
  }
});

function toggleUpgrades() {
  const panel = document.getElementById('upgrade-panel');
  panel.classList.toggle('open');
  if (panel.classList.contains('open')) renderUpgrades();
}

document.getElementById('close-upgrades').addEventListener('click', () => {
  document.getElementById('upgrade-panel').classList.remove('open');
});

document.getElementById('mo-vote-btn').addEventListener('click', () => {
  sendMsg({type: 'vote_rematch'});
  const btn = document.getElementById('mo-vote-btn');
  btn.disabled = true;
  btn.textContent = 'âœ“ VOTED';
});

// â”€â”€ Login â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function doJoin() {
  myName = document.getElementById('name-input').value.trim() || 'Commander';
  document.getElementById('status-msg').textContent = 'Connectingâ€¦';
  connect(myName);
}

document.getElementById('join-btn').addEventListener('click', doJoin);
document.getElementById('name-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') doJoin();
});

// â”€â”€ Particle System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const particles = [];
const screenFlashes = [];

function spawnExplosion(wx, wy, color='#f39c12', count=18) {
  for (let i=0; i<count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 3.5;
    particles.push({
      x: wx, y: wy,
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed,
      life: 0.6 + Math.random()*0.5,
      maxLife: 0.6 + Math.random()*0.5,
      size: 2 + Math.random()*5,
      color,
      type: Math.random() > 0.6 ? 'smoke' : 'spark',
    });
  }
  screenFlashes.push({alpha:0.18, color:'#f39c12', life:0.15});
}

function spawnMuzzleFlash(wx, wy) {
  for (let i=0; i<6; i++) {
    const angle = Math.random() * Math.PI * 2;
    particles.push({
      x:wx, y:wy,
      vx: Math.cos(angle)*2, vy: Math.sin(angle)*2,
      life:0.25, maxLife:0.25, size:3+Math.random()*4,
      color:'#fff', type:'spark',
    });
  }
}

function spawnCaptureEffect(wx, wy, color) {
  for (let i=0; i<8; i++) {
    const angle = (i/8)*Math.PI*2;
    particles.push({
      x:wx+Math.cos(angle)*20, y:wy+Math.sin(angle)*20,
      vx:Math.cos(angle)*0.5, vy:Math.sin(angle)*0.5,
      life:0.8, maxLife:0.8, size:4, color, type:'spark',
    });
  }
}

let lastParticleTime = performance.now();

function updateParticles(dt) {
  for (let i=particles.length-1; i>=0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.93;
    p.vy *= 0.93;
    if (p.type === 'smoke') { p.vy -= 0.03; p.size += 0.2; }
    p.life -= dt;
    if (p.life <= 0) particles.splice(i,1);
  }
  for (let i=screenFlashes.length-1; i>=0; i--) {
    screenFlashes[i].life -= dt;
    if (screenFlashes[i].life <= 0) screenFlashes.splice(i,1);
  }
}

function drawParticles() {
  // screen flash
  for (const f of screenFlashes) {
    ctx.fillStyle = f.color;
    ctx.globalAlpha = f.alpha * (f.life / 0.15);
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.globalAlpha = 1;
  }

  for (const p of particles) {
    const t = p.life / p.maxLife;
    const sc = worldToScreen(p.x, p.y);
    ctx.globalAlpha = t * 0.9;
    if (p.type === 'spark') {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(sc.x, sc.y, p.size*t, 0, Math.PI*2);
      ctx.fill();
    } else {
      // smoke puff
      const grad = ctx.createRadialGradient(sc.x,sc.y,0,sc.x,sc.y,p.size);
      grad.addColorStop(0, 'rgba(80,80,80,0.5)');
      grad.addColorStop(1, 'rgba(30,30,30,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(sc.x, sc.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
}

// track previous shell positions for impact detection
let prevShells = {};

// â”€â”€ Utility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function escHtml(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// â”€â”€ Asset loading + start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function init() {
  await Promise.all([
    loadAsset('tank_self',  'assets/tank_self.png'),
    loadAsset('tank_enemy', 'assets/tank_enemy.png'),
    loadAsset('fort_fuel',  'assets/fort_fuel.png'),
    loadAsset('fort_ammo',  'assets/fort_ammo.png'),
    loadAsset('fort_gear',  'assets/fort_gear.png'),
    loadAsset('fort_mixed', 'assets/fort_mixed.png'),
  ]);
  requestAnimationFrame(render);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MOBILE CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const isMobile = () => window.innerWidth <= 700 || ('ontouchstart' in window && window.innerWidth <= 900);

// â”€â”€ Mobile state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let mobTouches        = {};      // active touch points by identifier
let mobPinching       = false;   // two-finger gesture active
let mobPinchMid       = null;    // {x,y} midpoint last frame
let mobPinchDist      = null;    // distance last frame
let mobRecentPinch    = false;   // grace window after pinch ends
let mobHoldTimer      = null;    // setTimeout for long-press attack
let mobHoldPos        = null;    // screen position of hold
let mobChatUnread     = 0;
let mobChatOpen       = false;
let mobDrawerOpen     = false;
const HOLD_MS         = 420;     // ms to distinguish tap vs hold
const TAP_MOVE_THRESH = 12;      // px â€” movement beyond this cancels tap into pan

// â”€â”€ Utility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function mobSetPill(text, cls) {
  const p = document.getElementById('mobile-mode-pill');
  if (!p) return;
  p.textContent = text;
  p.className   = cls || '';
}

function mobSetMobBar(name, val, max) {
  const bar = document.getElementById(`mob-bar-${name}`);
  const lbl = document.getElementById(`mob-val-${name}`);
  if (!bar || !lbl) return;
  bar.style.width = Math.max(0, Math.min(100, (val / max) * 100)) + '%';
  lbl.textContent = Math.floor(val);
}

function mobUpdateHUD(tank) {
  if (!tank || !isMobile()) return;
  mobSetMobBar('hp',   tank.hp    ?? 0, tank.max_hp ?? 100);
  mobSetMobBar('fuel', tank.fuel  ?? 0, 120);
  mobSetMobBar('ammo', tank.ammo  ?? 0, 100);
  mobSetMobBar('gear', tank.gears ?? 0, 99);
}

// â”€â”€ Hold ring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showHoldRing(sx, sy) {
  const ring = document.getElementById('mob-hold-ring');
  ring.style.left = sx + 'px';
  ring.style.top  = sy + 'px';
  ring.classList.add('visible');
}
function hideHoldRing() {
  document.getElementById('mob-hold-ring').classList.remove('visible');
}

// â”€â”€ Drawer (map/stats) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openDrawer() {
  mobDrawerOpen = true;
  document.getElementById('mob-drawer').classList.add('open');
  document.getElementById('mob-drawer-backdrop').classList.add('open');
  mobUpdateDrawer();
}
function closeDrawer() {
  mobDrawerOpen = false;
  document.getElementById('mob-drawer').classList.remove('open');
  document.getElementById('mob-drawer-backdrop').classList.remove('open');
}
function mobUpdateDrawer() {
  if (!mobDrawerOpen || !gameState) return;
  // leaderboard
  const lb = document.getElementById('mob-leaderboard');
  lb.innerHTML = (gameState.leaderboard || []).map(l => `
    <div class="lb-row">
      <div class="lb-color" style="background:${l.color}"></div>
      <span class="lb-name">${escHtml(l.name)}</span>
      <span class="lb-forts">${l.forts}âš‘</span>
      <span class="lb-score">${l.score}</span>
    </div>`).join('');
  // forts
  const myForts = Object.values(gameState.forts).filter(f => f.owner === myPlayerId);
  document.getElementById('mob-fort-info').innerHTML = myForts.length === 0
    ? '<span>No forts controlled</span>'
    : myForts.map(f => `<div>âš‘ ${f.ftype.toUpperCase()} (${f.q},${f.r})</div>`).join('');
  // minimap â€” reuse renderMinimap but target mob canvas
  const mc = document.getElementById('mob-minimap-canvas');
  if (mc && gameState.visible_hexes) {
    const visSet = new Set(gameState.visible_hexes.map(h => `${h[0]},${h[1]}`));
    renderMinimapTo(mc, visSet);
  }
}

// render minimap to any canvas element
function renderMinimapTo(targetCanvas, visibleSet) {
  const mc = targetCanvas.getContext('2d');
  const W = targetCanvas.width, H = targetCanvas.height;
  mc.fillStyle = '#060910';
  mc.fillRect(0, 0, W, H);
  const S = W / (MAP_RADIUS * 2.2) / 1.73;
  const cx = W/2, cy = H/2;
  function mhp(q, r) { return { x: cx + S*(3/2*q), y: cy + S*(Math.sqrt(3)/2*q + Math.sqrt(3)*r) }; }
  for (let dq = -MAP_RADIUS; dq <= MAP_RADIUS; dq++) {
    for (let dr = Math.max(-MAP_RADIUS,-dq-MAP_RADIUS); dr <= Math.min(MAP_RADIUS,-dq+MAP_RADIUS); dr++) {
      const p = mhp(dq, dr);
      mc.fillStyle = visibleSet.has(`${dq},${dr}`) ? '#0d1117' : '#070a0e';
      mc.beginPath();
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI/3)*i;
        i === 0 ? mc.moveTo(p.x+(S-0.5)*Math.cos(a), p.y+(S-0.5)*Math.sin(a))
                : mc.lineTo(p.x+(S-0.5)*Math.cos(a), p.y+(S-0.5)*Math.sin(a));
      }
      mc.closePath(); mc.fill();
    }
  }
  for (const fort of Object.values(gameState.forts)) {
    const p = mhp(fort.q, fort.r);
    mc.fillStyle = fort.owner ? (FORT_COLORS[fort.ftype] || '#8e44ad') : (FORT_COLORS[fort.ftype] || '#8e44ad') + '55';
    mc.beginPath(); mc.arc(p.x, p.y, S*0.4, 0, Math.PI*2); mc.fill();
  }
  for (const [pid, tank] of Object.entries(gameState.tanks)) {
    if (!tank.alive) continue;
    const p = mhp(tank.q, tank.r);
    mc.fillStyle = tank.color;
    mc.beginPath(); mc.arc(p.x, p.y, pid === myPlayerId ? S*0.65 : S*0.45, 0, Math.PI*2); mc.fill();
    if (pid === myPlayerId) { mc.strokeStyle = '#fff'; mc.lineWidth = 1; mc.stroke(); }
  }
}

// â”€â”€ Chat overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openMobChat() {
  mobChatOpen = true;
  document.getElementById('mob-chat-overlay').classList.add('open');
  // clear unread badge
  mobChatUnread = 0;
  const badge = document.getElementById('mob-chat-badge');
  badge.classList.remove('visible');
  badge.textContent = '';
  // focus input after keyboard animation
  setTimeout(() => document.getElementById('mob-chat-input').focus(), 120);
  // scroll to bottom
  const msgs = document.getElementById('mob-chat-messages');
  msgs.scrollTop = msgs.scrollHeight;
}
function closeMobChat() {
  mobChatOpen = false;
  document.getElementById('mob-chat-overlay').classList.remove('open');
  document.getElementById('mob-chat-input').blur();
}

// Mirror messages into mobile chat panel
const _origAddChatMsg = addChatMsg;  // addChatMsg defined earlier
function addChatMsgMobile(msg) {
  const box = document.getElementById('mob-chat-messages');
  if (!box) return;
  const el = document.createElement('div');
  if (msg.kind === 'chat') {
    el.className = 'chat-msg';
    el.innerHTML = `<span class="chat-ts">${fmtTime(msg.ts)}</span>`
      + `<span class="chat-name" style="color:${escHtml(msg.color)}">${escHtml(msg.name)}:</span>`
      + `<span class="chat-text">${escHtml(msg.text)}</span>`;
  } else if (msg.kind === 'killfeed') {
    el.className = 'chat-msg killfeed';
    el.innerHTML = `<span class="chat-ts">${fmtTime(msg.ts)}</span>`
      + `<span class="chat-text"><span style="color:${escHtml(msg.killerColor)}">${escHtml(msg.killer)}</span>`
      + ` â˜  <span style="color:${escHtml(msg.victimColor)}">${escHtml(msg.victim)}</span></span>`;
  } else if (msg.kind === 'capturefeed') {
    el.className = 'chat-msg capturefeed';
    el.innerHTML = `<span class="chat-ts">${fmtTime(msg.ts)}</span>`
      + `<span class="chat-text"><span style="color:${escHtml(msg.color)}">${escHtml(msg.name)}</span>`
      + ` captured ${escHtml(msg.fortType)} fort</span>`;
  }
  box.appendChild(el);
  box.scrollTop = box.scrollHeight;
  while (box.children.length > 80) box.removeChild(box.firstChild);
  // badge when closed
  if (!mobChatOpen && isMobile() && msg.kind === 'chat') {
    mobChatUnread = Math.min(99, mobChatUnread + 1);
    const badge = document.getElementById('mob-chat-badge');
    badge.textContent = mobChatUnread;
    badge.classList.add('visible');
  }
}

// Patch addChatMsg to also feed mobile panel
const _addChatMsgOriginal = addChatMsg;
window.addChatMsg = function(msg) {
  _addChatMsgOriginal(msg);
  if (isMobile()) addChatMsgMobile(msg);
};

// Mobile chat send
function sendMobChat() {
  const input = document.getElementById('mob-chat-input');
  const text  = input.value.trim();
  if (!text || !myPlayerId) return;
  sendMsg({type: 'chat', text});
  input.value = '';
}
document.getElementById('mob-chat-send').addEventListener('click', sendMobChat);
document.getElementById('mob-chat-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') { e.preventDefault(); sendMobChat(); }
  e.stopPropagation();
});
document.getElementById('mob-chat-close').addEventListener('click', closeMobChat);
document.getElementById('mob-drawer-close').addEventListener('click', closeDrawer);
document.getElementById('mob-drawer-backdrop').addEventListener('click', closeDrawer);

// FABs
document.getElementById('fab-upgrade').addEventListener('click', toggleUpgrades);
document.getElementById('fab-map').addEventListener('click', openDrawer);
document.getElementById('fab-chat').addEventListener('click', openMobChat);
document.getElementById('fab-center').addEventListener('click', () => {
  if (gameState?.tanks?.[myPlayerId]) {
    const t = gameState.tanks[myPlayerId];
    const p = hexToPixel(t.q, t.r);
    camX = p.x; camY = p.y;
  }
});

// â”€â”€ Touch input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getTouchMid(t1, t2) {
  return { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
}
function getTouchDist(t1, t2) {
  const dx = t1.clientX - t2.clientX, dy = t1.clientY - t2.clientY;
  return Math.sqrt(dx*dx + dy*dy);
}
function cancelHold() {
  clearTimeout(mobHoldTimer);
  mobHoldTimer = null;
  mobHoldPos   = null;
  hideHoldRing();
}

canvas.addEventListener('touchstart', e => {
  if (!isMobile()) return;
  e.preventDefault();
  const touches = Array.from(e.touches);

  // Record all active touches
  for (const t of Array.from(e.changedTouches)) {
    mobTouches[t.identifier] = { x: t.clientX, y: t.clientY, startX: t.clientX, startY: t.clientY };
  }

  if (touches.length >= 2) {
    // Two-finger gesture â€” cancel any pending tap/hold
    cancelHold();
    isDragging = false; dragPath = []; dragMode = null;
    mobPinching  = true;
    mobPinchMid  = getTouchMid(touches[0], touches[1]);
    mobPinchDist = getTouchDist(touches[0], touches[1]);
    return;
  }

  // One finger
  if (touches.length === 1 && !mobPinching && !mobRecentPinch) {
    const t = touches[0];
    const rect = canvas.getBoundingClientRect();
    const sx = t.clientX - rect.left, sy = t.clientY - rect.top;
    mobHoldPos = { sx, sy, clientX: t.clientX, clientY: t.clientY };

    // Start hold timer â€” fires as attack
    mobHoldTimer = setTimeout(() => {
      if (!mobHoldPos) return;
      const tank = gameState?.tanks?.[myPlayerId];
      if (!tank || !tank.alive) return;
      const hex = screenToHex(mobHoldPos.sx, mobHoldPos.sy);
      showHoldRing(mobHoldPos.clientX, mobHoldPos.clientY);
      mobSetPill('FIRE', 'attack-mode');
      setTimeout(() => {
        sendMsg({ type: 'shoot', target_q: hex.q, target_r: hex.r });
        hideHoldRing();
        mobSetPill('TAP TO MOVE Â· HOLD TO FIRE', '');
      }, 80);
      mobHoldTimer = null;
      mobHoldPos   = null;
    }, HOLD_MS);
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  if (!isMobile()) return;
  e.preventDefault();
  const touches = Array.from(e.touches);

  // Update stored positions
  for (const t of Array.from(e.changedTouches)) {
    if (mobTouches[t.identifier]) {
      mobTouches[t.identifier].x = t.clientX;
      mobTouches[t.identifier].y = t.clientY;
    }
  }

  if (touches.length >= 2) {
    const newMid  = getTouchMid(touches[0], touches[1]);
    const newDist = getTouchDist(touches[0], touches[1]);

    if (mobPinchMid && mobPinchDist) {
      // Pan â€” shift camera by midpoint delta
      const dx = (newMid.x - mobPinchMid.x) / camScale;
      const dy = (newMid.y - mobPinchMid.y) / camScale;
      camX -= dx; camY -= dy;

      // Zoom â€” scale by distance ratio, anchored on midpoint
      const rect  = canvas.getBoundingClientRect();
      const mx    = newMid.x - rect.left;
      const my    = newMid.y - rect.top;
      const before = screenToWorld(mx, my);
      camScale    = Math.max(0.3, Math.min(3.0, camScale * (newDist / mobPinchDist)));
      const after  = screenToWorld(mx, my);
      camX += before.x - after.x;
      camY += before.y - after.y;
    }
    mobPinchMid  = newMid;
    mobPinchDist = newDist;
    return;
  }

  // Single finger movement â€” check if it's drifted too far (becomes pan)
  if (touches.length === 1 && mobHoldPos) {
    const t   = touches[0];
    const dx  = t.clientX - mobHoldPos.clientX;
    const dy  = t.clientY - mobHoldPos.clientY;
    const d   = Math.sqrt(dx*dx + dy*dy);
    if (d > TAP_MOVE_THRESH) {
      // Treat as pan
      cancelHold();
      const wdx = dx / camScale, wdy = dy / camScale;
      camX -= (t.clientX - (mobHoldPos.clientX)) / camScale;
      camY -= (t.clientY - (mobHoldPos.clientY)) / camScale;
      mobHoldPos = { ...mobHoldPos, clientX: t.clientX, clientY: t.clientY };
    }
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  if (!isMobile()) return;
  e.preventDefault();
  for (const t of Array.from(e.changedTouches)) delete mobTouches[t.identifier];

  const remaining = Array.from(e.touches);

  if (mobPinching && remaining.length < 2) {
    mobPinching  = false;
    mobPinchMid  = null;
    mobPinchDist = null;
    // Grace window so lifting one finger doesn't fire a move
    mobRecentPinch = true;
    setTimeout(() => { mobRecentPinch = false; }, 180);
    return;
  }

  // Finger lifted â€” if hold timer still pending, it's a tap â†’ MOVE
  if (mobHoldTimer !== null) {
    clearTimeout(mobHoldTimer);
    mobHoldTimer = null;
    if (!mobRecentPinch && mobHoldPos) {
      const tank = gameState?.tanks?.[myPlayerId];
      if (tank && tank.alive) {
        const hex = screenToHex(mobHoldPos.sx, mobHoldPos.sy);
        const tankHex = { q: Math.round(tank.q), r: Math.round(tank.r) };
        const path = hexPathfind(tankHex, hex);
        if (path.length > 0) {
          sendMsg({ type: 'move', path: path.map(h => [h.q, h.r]) });
          mobSetPill('MOVING', 'move-mode');
          setTimeout(() => mobSetPill('TAP TO MOVE Â· HOLD TO FIRE', ''), 800);
        }
      }
    }
    mobHoldPos = null;
  }
}, { passive: false });

canvas.addEventListener('touchcancel', e => {
  cancelHold();
  mobPinching = false; mobPinchMid = null; mobPinchDist = null;
  for (const t of Array.from(e.changedTouches)) delete mobTouches[t.identifier];
}, { passive: false });

// Patch updateUI to also push to mobile HUD and drawer
const _origUpdateUI = updateUI;
window.updateUI = function() {
  _origUpdateUI();
  if (!isMobile() || !gameState || !myPlayerId) return;
  const tank = gameState.tanks[myPlayerId];
  if (tank) mobUpdateHUD(tank);
  if (mobDrawerOpen) mobUpdateDrawer();
};

// Init pill text on mobile
if (isMobile()) mobSetPill('TAP TO MOVE Â· HOLD TO FIRE', '');

init();
</script>
</body>
</html>